-- Enhanced Roblox Game Loader with Dynamic Game List
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- Wait for player
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    LocalPlayer = Players.LocalPlayer
end

-- Configuration
local GAMES_LIST_URL = "https://gist.githubusercontent.com/skyDevO01/67ab88eb2ba4f61fb236894163a31139/raw/6831d71f6f5d4f45ed71329271f58edb50ae5b97/Games%2520Lists.Lua"
local SupportedGames = {}

-- Create animated loading GUI
local function createLoaderGUI(gameName, accentColor)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GameLoader"
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.ResetOnSpawn = false

    -- Main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 400, 0, 250)
    mainFrame.Position = UDim2.new(0.5, -200, 0.5, -125)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui

    -- Corner rounding
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = mainFrame

    -- Stroke
    local stroke = Instance.new("UIStroke")
    stroke.Color = accentColor
    stroke.Thickness = 2
    stroke.Parent = mainFrame

    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 60)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "Loading Script"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextScaled = true
    title.Font = Enum.Font.GothamBold
    title.Parent = mainFrame

    -- Game name
    local gameLabel = Instance.new("TextLabel")
    gameLabel.Size = UDim2.new(1, 0, 0, 40)
    gameLabel.Position = UDim2.new(0, 0, 0, 60)
    gameLabel.BackgroundTransparency = 1
    gameLabel.Text = gameName
    gameLabel.TextColor3 = accentColor
    gameLabel.TextScaled = true
    gameLabel.Font = Enum.Font.Gotham
    gameLabel.Parent = mainFrame

    -- Loading animation container
    local loadingContainer = Instance.new("Frame")
    loadingContainer.Size = UDim2.new(0, 200, 0, 80)
    loadingContainer.Position = UDim2.new(0.5, -100, 0.7, -40)
    loadingContainer.BackgroundTransparency = 1
    loadingContainer.Parent = mainFrame

    -- Animated loading dots
    local dots = {}
    for i = 1, 3 do
        local dot = Instance.new("Frame")
        dot.Size = UDim2.new(0, 20, 0, 20)
        dot.Position = UDim2.new(i * 0.25, -10, 0.5, -10)
        dot.BackgroundColor3 = accentColor
        dot.BorderSizePixel = 0
        dot.Parent = loadingContainer
        
        local dotCorner = Instance.new("UICorner")
        dotCorner.CornerRadius = UDim.new(1, 0)
        dotCorner.Parent = dot
        
        dots[i] = dot
    end

    -- Status text
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -40, 0, 30)
    statusLabel.Position = UDim2.new(0, 20, 0, 180)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Initializing..."
    statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusLabel.TextSize = 16
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.Parent = mainFrame

    -- Progress bar background
    local progressBg = Instance.new("Frame")
    progressBg.Size = UDim2.new(1, -40, 0, 8)
    progressBg.Position = UDim2.new(0, 20, 0, 160)
    progressBg.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    progressBg.BorderSizePixel = 0
    progressBg.Parent = mainFrame
    
    local progressBgCorner = Instance.new("UICorner")
    progressBgCorner.CornerRadius = UDim.new(1, 0)
    progressBgCorner.Parent = progressBg

    -- Progress bar fill
    local progressFill = Instance.new("Frame")
    progressFill.Size = UDim2.new(0, 0, 1, 0)
    progressFill.BackgroundColor3 = accentColor
    progressFill.BorderSizePixel = 0
    progressFill.Parent = progressBg
    progressFill.ZIndex = 2
    
    local progressFillCorner = Instance.new("UICorner")
    progressFillCorner.CornerRadius = UDim.new(1, 0)
    progressFillCorner.Parent = progressFill

    return screenGui, dots, statusLabel, progressFill
end

-- Animate loading dots
local function animateDots(dots, accentColor)
    local connection
    local startTime = tick()
    
    connection = RunService.Heartbeat:Connect(function()
        local time = tick() - startTime
        for i, dot in ipairs(dots) do
            local offset = (i - 1) * 0.2
            local alpha = math.sin((time + offset) * 5) * 0.5 + 0.5
            dot.BackgroundColor3 = accentColor:Lerp(Color3.fromRGB(100, 100, 100), 1 - alpha)
            dot.Size = UDim2.new(0, 15 + alpha * 10, 0, 15 + alpha * 10)
        end
    end)
    
    return connection
end

-- Update progress bar
local function updateProgress(progressFill, statusLabel, progress, message)
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(progressFill, tweenInfo, {Size = UDim2.new(progress, 0, 1, 0)})
    tween:Play()
    
    if statusLabel then
        statusLabel.Text = message
    end
end

-- Load and execute script with error handling
local function loadGameScript(scriptUrl, gameName, accentColor)
    local gui, dots, statusLabel, progressFill = createLoaderGUI(gameName, accentColor)
    local dotAnimation = animateDots(dots, accentColor)
    
    -- Simulate loading stages
    local loadingStages = {
        {"Downloading script...", 0.4},
        {"Verifying script...", 0.6},
        {"Compiling...", 0.8},
        {"Executing...", 1.0}
    }
    
    local function executeNextStage(index)
        if index > #loadingStages then
            return
        end
        
        local stage = loadingStages[index]
        updateProgress(progressFill, statusLabel, stage[2], stage[1])
        
        wait(0.5 + math.random() * 0.5)
        
        executeNextStage(index + 1)
    end
    
    -- Start loading animation
    executeNextStage(1)
    
    -- Actual script loading
    local success, result = pcall(function()
        updateProgress(progressFill, statusLabel, 0.4, "Downloading script content...")
        
        -- Load the external script
        local response = game:HttpGetAsync(scriptUrl)
        
        updateProgress(progressFill, statusLabel, 0.7, "Compiling script...")
        
        -- Use loadstring to compile the script
        local compiledScript, compileError = loadstring(response)
        if not compiledScript then
            --error("Compilation failed: " .. tostring(compileError))
        end
        
        updateProgress(progressFill, statusLabel, 0.9, "Executing script...")
        
        -- Execute the compiled script
        return compiledScript()
    end)
    
    -- Clean up animation
    if dotAnimation then
        dotAnimation:Disconnect()
    end
    
    if success then
        updateProgress(progressFill, statusLabel, 1.0, "Script loaded successfully!")
        wait(1)
        gui:Destroy()
        return true
    else
        updateProgress(progressFill, statusLabel, 1.0, "Loading failed: " .. tostring(result))
        statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        wait(3)
        gui:Destroy()
        return false, result
    end
end

-- Load supported games list from GitHub
local function loadSupportedGames()
    local success, gamesTable = pcall(function()
        -- Download the games list
        local gamesListResponse = game:HttpGetAsync(GAMES_LIST_URL)
        
        -- Use loadstring to convert the response to a Lua table
        local gamesListFunction, compileError = loadstring(gamesListResponse)
        if not gamesListFunction then
            --error("Failed to compile games list: " .. tostring(compileError))
        end
        
        -- Execute the function to get the table
        return gamesListFunction()
    end)
    
    if success and gamesTable then
        return gamesTable
    else
        --warn("Failed to load supported games list: " .. tostring(gamesTable))
        return {}
    end
end

-- Generate random accent color for games
local function generateAccentColor(placeId)
    -- Use placeId as seed for consistent colors per game
    local r = (placeId * 1234567 % 155) + 100
    local g = (placeId * 7654321 % 155) + 100
    local b = (placeId * 9876543 % 155) + 100
    return Color3.fromRGB(r, g, b)
end

-- Create simple notification
local function createNotification(message, isError)
    local notifyGui = Instance.new("ScreenGui")
    notifyGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 80)
    frame.Position = UDim2.new(1, -320, 1, -100)
    frame.BackgroundColor3 = isError and Color3.fromRGB(60, 30, 30) or Color3.fromRGB(30, 40, 30)
    frame.BorderSizePixel = 0
    frame.Parent = notifyGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = isError and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(100, 255, 100)
    stroke.Thickness = 2
    stroke.Parent = frame
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -20, 1, -20)
    label.Position = UDim2.new(0, 10, 0, 10)
    label.BackgroundTransparency = 1
    label.Text = message
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.TextWrapped = true
    label.Parent = frame
    
    -- Auto-remove after 5 seconds
    delay(5, function()
        notifyGui:Destroy()
    end)
    
    return notifyGui
end

-- Main execution function
local function main()
    local currentPlaceId = game.PlaceId
    
    -- Create initial loading GUI for games list
    local initialGui, initialDots, initialStatus, initialProgress = createLoaderGUI("Loading Games List", Color3.fromRGB(100, 150, 255))
    local initialAnimation = animateDots(initialDots, Color3.fromRGB(100, 150, 255))
    
    updateProgress(initialProgress, initialStatus, 0.3, "Downloading games list...")
    
    -- Load supported games
    SupportedGames = loadSupportedGames()
    
    updateProgress(initialProgress, initialStatus, 0.8, "Processing games list...")
    wait(0.5)
    
    -- Clean up initial loader
    if initialAnimation then
        initialAnimation:Disconnect()
    end
    initialGui:Destroy()
    
    -- Check if games list was loaded successfully
    if not next(SupportedGames) then
        createNotification("Failed to load games list\nPlease check your connection", true)
        --warn("Failed to load supported games list from: " .. GAMES_LIST_URL)
        return
    end
    
    -- Check if current game is supported
    if SupportedGames[currentPlaceId] then
        local gameInfo = SupportedGames[currentPlaceId]
        local accentColor = generateAccentColor(currentPlaceId)
        
        --warn("Detected supported game: " .. gameInfo.name .. " (" .. currentPlaceId .. ")")
        
        local success, errorMsg = loadGameScript(
            gameInfo.url,
            gameInfo.name,
            accentColor
        )
        
        if success then
            createNotification("Script for " .. gameInfo.name .. " loaded successfully!", false)
            --warn("Script for " .. gameInfo.name .. " loaded successfully!")
        else
            createNotification("Failed to load script for " .. gameInfo.name, true)
            --warn("Failed to load script for " .. gameInfo.name .. ": " .. tostring(errorMsg))
        end
    else
        createNotification("Game not supported\nPlaceId: " .. currentPlaceId, true)
        --warn("Game not supported: " .. currentPlaceId)
        --warn("Supported games: " .. HttpService:JSONEncode(SupportedGames))
    end
end

-- Start the script
local success, errorMsg = pcall(main)

if not success then
    --warn("Loader script error: " .. tostring(errorMsg))
    createNotification("Loader error: " .. tostring(errorMsg), true)
end
